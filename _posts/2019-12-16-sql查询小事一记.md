---
published: false
---


早上要对产品某个功能进行复盘，需要查询在当前所有的付费用户中店铺的商品数量分布情况。因为表设计结构问题，所有订单均显示在同一张表，并且表中没有对应过期时间字段，过期时间字段又维护在了另外一张表，从而导致要联合查询时，需要同时关联三张表进行查询。具体操作比较常规简单，因涉及到业务逻辑表述，暂且跳过。
在查询过程中碰到了一个问题：需要取用户当前最新的一笔订购订单做关联查询。条件反射的马上用起了max函数，内容如下：

>select max(add_time) from x where id=小明;

执行结果只出来了小明最新的创建时间，这明显不符合我的要求，因为我还需要其他字段信息。于是，我条件反射的又换一种查询，加入了group by分组函数
>SELECT *,max(add_time)from x where owner_id=小明 group by owner_id;

可想而知，这明显又没办法符合查询需求，因为max(add_time)的字段只会并入查询中，从而检索出来的字段并不可用。
我突然有点魔怔，因为这个查询我偶尔使用，但是突然就是记不起来。求助了百度、知乎、谷歌，发现往上有很多人也遇到过这个问题，被它所困，有各个论坛均有成千上万关于这方面的问题，答案五花八门，还没验证就已经下班了。于是趁着现在午休的时间，我想了一下，有2个方案，写在这里，一方面练练文笔消磨时间，另一方面也当作记录，方便下次脑子短路的时候可以看到。
>#1
方法：简单粗暴，适用数据量较少，单条查询场景
步骤：利用desc获得该条件倒序视图，用limit1获取
selevt * from pdd_user_login_log where owner_id=xxx order by login_time desc limit 1

>#2
方法：较为通用的方法，查询速度相比方法1应该会好一点
步骤：利用子查询得到倒序视图，再用group by获取结果
select * from (select * from pdd_user_login_log) where owner_id=xxx order by login_time desc limit 1)a group by a.owner_id

基本方法如上，不过我此刻对group by分组查询的实现原理和处理有些疑问和兴趣，等完全吃透了，再回来更新。